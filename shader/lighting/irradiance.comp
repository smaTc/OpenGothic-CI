#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable

#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 128) in;

shared vec4 samples[128][3][2]; // 12 Kb

layout(binding = 0) uniform writeonly image2D result;
layout(binding = 1, std140) uniform UboScene {
  SceneDesc scene;
  };
layout(binding = 2) uniform sampler2D skyLUT;

// Sample i-th point from Hammersley point set of NumSamples points total.
// See: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
vec2 sampleHammersley(uint i, uint numSamples) {
  uint bits = bitfieldReverse(i);
  float vdc = float(bits) * 2.3283064365386963e-10; // / 0x100000000
  return vec2(float(i)/float(numSamples), vdc);
  }

vec3 sampleHemisphere(uint i, uint numSamples, float offsetAng) {
  const vec2  xi  = sampleHammersley(i,numSamples);
  const float u1p = sqrt(max(0.0, 1.0 - xi.y*xi.y));
  const float a   = M_PI*2.0*xi.x + offsetAng;
  return vec3(cos(a) * u1p, xi.y, sin(a) * u1p);
  }

void storeSample(vec3 dir, vec3 val) {
  for(int i=0; i<3; ++i) {
    float v = dir[i];
    int   d = v>=0 ? 1 : 0;
    v = abs(v);
    samples[gl_LocalInvocationIndex][i][d] += vec4(val*v, v);
    }
  }

void main() {
  const uint laneId = gl_LocalInvocationIndex;

  for(int i=0; i<3; ++i) {
    samples[laneId][i][0] = vec4(0);
    samples[laneId][i][1] = vec4(0);
    }

  vec3 dir = sampleHemisphere(laneId, gl_WorkGroupSize.x, 0);
  vec3 sky = vec3(0);
  sky += textureSkyLUT(skyLUT, vec3(0,RPlanet,0), +dir, scene.sunDir);
  sky += textureSkyLUT(skyLUT, vec3(0,RPlanet,0), -dir, scene.sunDir);
  sky *= scene.GSunIntensity;

  storeSample(dir, sky);
  barrier();

  for(uint i=gl_WorkGroupSize.x; i>0;) {
    i /= 2;
    if(laneId<i) {
      for(int r=0; r<3; ++r) {
        samples[laneId][r][0] += samples[laneId+i][r][0];
        samples[laneId][r][1] += samples[laneId+i][r][1];
        }
      }
    barrier();
    }

  if(laneId<3) {
    vec4 a = samples[0][laneId][0];
    vec4 b = samples[0][laneId][1];

    if(a.w>0)
      a.rgb /= a.w;
    if(b.w>0)
      b.rgb /= b.w;

    imageStore(result, ivec2(laneId,0), vec4(a.rgb,1.0));
    imageStore(result, ivec2(laneId,1), vec4(b.rgb,1.0));
    }
  }
