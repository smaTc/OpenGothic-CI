#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable

#include "sky_common.glsl"

layout(binding = 0) uniform sampler2D tLUT;
layout(binding = 1) uniform sampler2D mLUT;
//layout(binding = 2) uniform sampler2D depth;
layout(binding = 3) uniform writeonly image3D fogLut;

layout(local_size_x = 8, local_size_y = 8) in;

void store(ivec3 at, vec3 lum, vec3 trans) {
  float t = (trans.x+trans.y+trans.z)/3.0;
  imageStore(fogLut, at, vec4(lum,t));
  }

vec3 ftransmittance(vec3 pos0, vec3 pos1) {
  const int   steps = 64;
  const float scale = 60.0;

  vec3  transmittance = vec3(1.0);
  vec3  dir  = pos1-pos0;
  float dist = length(dir);
  for(int i=1; i<=steps; ++i) {
    float t      = (float(i)/steps);
    float dt     = dist/steps;
    vec3  newPos = pos0 + t*dir + vec3(0,RPlanet,0);

    vec3  rayleighScattering = vec3(0);
    vec3  extinction         = vec3(0);
    float mieScattering      = float(0);
    scatteringValues(newPos, rayleighScattering, mieScattering, extinction);

    transmittance *= exp(-dt*extinction*scale);
    }
  return transmittance;
  }

vec3 luminance(const vec2 inPos) {
  const vec2  uv       = inPos*vec2(0.5)+vec2(0.5);
  const vec3  viewPos  = vec3(0.0, RPlanet + push.plPosY, 0.0);

  const vec3  pos1     = inverse(vec3(inPos,1));
  const vec3  pos0     = inverse(vec3(inPos,0));

  const float dist     = length(pos1-pos0);
  const vec3  dir      = normalize(pos1-pos0);

  const vec3  sunDir   = vec3(push.sunDir);
  const float cosTheta = dot(dir, sunDir);

  //---
  const int   steps   = 64;

  float miePhaseValue      = miePhase(cosTheta);
  float rayleighPhaseValue = rayleighPhase(-cosTheta);

  vec3  lum                = vec3(0.0);
  vec3  transmittance      = vec3(1.0);

  for(int i=0; i<steps; ++i) {
    float t  = (float(i+0.5)/steps)*dist;
    float dt = dist/steps;

    vec3  newPos = pos0 + t*dir + vec3(0,RPlanet,0);

    vec3  rayleighScattering;
    vec3  extinction;
    float mieScattering;
    scatteringValues(newPos, rayleighScattering, mieScattering, extinction);

    vec3 sampleTransmittance = exp(-dt*extinction);

    vec3 sunTransmittance = textureLUT(tLUT, newPos, sunDir);
    vec3 psiMS            = textureLUT(mLUT, newPos, sunDir);

    vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
    vec3 mieInScattering      = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
    vec3 inScattering         = (rayleighInScattering + mieInScattering);

    // Integrated scattering within path segment.
    vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

    lum += scatteringIntegral*transmittance;

    transmittance *= sampleTransmittance;
    }

  return lum;

  //const float tMax    = length(pos1-pos0);
  //const vec3  rayDir  = (pos1-pos0)/tMax;
  //return raymarchScattering(viewPos, rayDir, sunDir, tMax);
  }

void main() {
  const ivec3 dstSz = imageSize(fogLut);
  const ivec3 dstUV = ivec3(gl_GlobalInvocationID.xy,0);
  if(dstUV.x>=dstSz.x || dstUV.x>=dstSz.x)
    return;

  const int   steps  = dstSz.z;
  const float tScale = 30.0;

  const vec2  inPos  = ((vec2(dstUV.xy)+vec2(0.5))/vec2(dstSz.xy))*2.0-vec2(1.0);
  const vec3  pos1   = inverse(vec3(inPos,1));
  const vec3  pos0   = inverse(vec3(inPos,0));

  const float dist   = length(pos1-pos0);
  const vec3  dir    = normalize(pos1-pos0);

  const vec3  sunDir             = vec3(push.sunDir);
  const float cosTheta           = dot(dir, sunDir);
  const float miePhaseValue      = miePhase(cosTheta);
  const float rayleighPhaseValue = rayleighPhase(-cosTheta);

  vec3  lum            = vec3(0.0);
  vec3  transmittance  = vec3(1.0);
  vec3  transmittanceS = vec3(1.0);
  for(int i=0; i<steps; ++i) {
    float t      = (float(i+0.5)/steps)*dist;
    float dt     = dist/steps;

    vec3  newPos = pos0 + t*dir + vec3(0,RPlanet,0);

    vec3  rayleighScattering;
    vec3  extinction;
    float mieScattering;
    scatteringValues(newPos, rayleighScattering, mieScattering, extinction);

    vec3 sampleTransmittance  = exp(-dt*extinction);
    vec3 sampleTransmittanceS = exp(-dt*extinction*tScale);

    vec3 sunTransmittance = textureLUT(tLUT, newPos, sunDir);
    vec3 psiMS            = textureLUT(mLUT, newPos, sunDir);

    vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
    vec3 mieInScattering      = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
    vec3 inScattering         = (rayleighInScattering + mieInScattering);

    // Integrated scattering within path segment.
    vec3 scatteringIntegral   = (inScattering - inScattering * sampleTransmittance) / extinction;

    lum += scatteringIntegral*transmittance;

    transmittance  *= sampleTransmittance;
    transmittanceS *= sampleTransmittanceS;

    store(ivec3(dstUV.xy,i), lum, transmittanceS);
    }

  vec3 trans = luminance(inPos);
  for(int i=0; i<steps; ++i) {
    float a     = (float(i))/float(steps);
    vec3  pos   = mix(pos0,pos1,a);
    //const vec3  pos1   = inverse(vec3(inPos,a));
    //vec3  trans = ftransmittance(pos0, pos1);

    // store(ivec3(dstUV.xy,i), vec3(trans), 1.0);
    }
  }
